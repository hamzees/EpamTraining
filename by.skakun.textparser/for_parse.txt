Лямбда-выражение представляет собой блок кода, который можно передать в другое место, поэтому он может быть выполнен позже, один или несколько раз. Прежде чем углубляться в синтаксис (и любопытное название), давайте сделаем шаг назад и увидим, где вы использовали аналогичные блоки кода в Java до этого. 

Если вы хотите выполнить действия в отдельном потоке, вы помещаете их в метод run из Runnable, вот так:
///
class MyRunner implements Runnable {
    public void run() {
        for (int i = 0; i < 1000; i++)
           doWork();
        }
        ...
}
///
Затем, когда вы хотите выполнить этот код, вы создаете экземпляр класса MyRunner. Вы можете поместить экземпляр в пул потоков, или поступить проще и запустить новый поток:
MyRunner r = new MyRunner();
new Thread(r).start();

Ключевым моментом является то, что метод run содержит код, который нужно выполнить в отдельном потоке.

Рассмотрим сортировку с использованием пользовательского компаратора. Если вы хотите отсортировать строки по длине, а не по умолчанию, вы можете передать объект Comparator в метод sort:
///
class LengthStringComparator implements Comparator<String> {
    public int compare(String firstStr, String secondStr) {
        return Integer.compare(firstStr.length(),secondStr.length());
    }
}
///   
Arrays.sort(strings, new LengthStringComparator ());

Метод sort все так же вызывает метод compare, переставляя элементы, если они стоят не по порядку, пока массив не будет отсортирован. Вы предоставляете методу sort фрагмент кода, необходимый для сравнения элементов, и этот код встраивается в остальную часть логики сортировки, которую вам, вероятно, не нужно переопределять. Обратите внимание, что вызов Integer.compare (х, у) возвращает ноль, если х и у равны, отрицательное число, если х < у, и положительное число, если х > у. Этот статический метод был добавлен в Java 7. Вы не должны вычислять х – y, чтобы сравнивать х и у, потому что расчет может вызвать переполнение для больших операндов противоположного знака.

В качестве другого примера отложенного выполнения рассмотрим коллбэк для кнопки. Вы помещаете действие обратного вызова в метод класса, реализующего интерфейс слушателя, создаете экземпляр, и регистрируете экземпляр. Это настолько распространенный сценарий, что многие программисты используют синтаксис «анонимный экземпляр анонимного класса»:
///
button.setOnAction(new EventHandler<ActionEvent>() {
    public void handle(ActionEvent event) {
        System.out.println("The button has been clicked!");
    }
});
///
Здесь важен код внутри метода handle. Этот код выполняется всякий раз, когда нажимается кнопка.

Поскольку Java 8 позиционирует JavaFX в качестве преемника инструментария Swing GUI, я использую JavaFX в этих примерах. Детали не имеют значения. В каждой библиотеке пользовательского интерфейса, будь то Swing, JavaFX или Android, вы передаете кнопке некоторый код, который вы хотите запустить, когда кнопка нажата.

Во всех трех примерах вы видели один и тот же подход. Блок кода кому-то передавался — пулу потоков, методу сортировки или кнопке. Этот код вызывался некоторое время спустя.

До сих пор передача кода не была простой в Java. Вы не могли просто передать блоки кода куда угодно. Java является объектно-ориентированным языком, так что вы должны были создать объект, принадлежащий к классу, у которого есть метод с нужным кодом.
В других языках можно работать с блоками кода непосредственно. Проектировщики Java сопротивлялись добавлению этой функции в течение длительного времени. В конце концов, большая сила Java в ее простоте и последовательности. Язык может стать крайне беспорядочным, если будет включать в себя все функции, которые дают чуть более краткий код. Тем не менее, в тех других языках, это не просто легче порождать поток или зарегистрировать обработчик кнопки щелчка; многие их API проще, более последовательны и мощные. В Java, можно было бы написать подобные интерфейсы, которые принимают объекты классов, реализующих определенную функцию, но такие API было бы неудобно использовать.

В последнее время вопрос был не в том, расширять Java для функционального программирования или нет, а как это сделать. Потребовалось несколько лет экспериментов, прежде чем выяснилось, что это хорошо подходит для Java. В следующем разделе вы увидите, как можно работать с блоками кода в Java 8.